package auth

import (
	"database/sql"
	"os"
	"testing"

	"github.com/maxiofs/maxiofs/internal/config"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestJWTSecretPersistence_AutoGenerated verifies that an auto-generated JWT secret
// is persisted to the database and reused on subsequent manager creation
func TestJWTSecretPersistence_AutoGenerated(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "maxiofs-jwt-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// First manager: auto-generated secret should be saved to DB
	cfg1 := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "auto-generated-secret-for-testing",
		JWTSecretAutoGenerated: true,
	}
	manager1 := NewManager(cfg1, tmpDir)
	require.NotNil(t, manager1)

	am1 := manager1.(*authManager)
	firstSecret := am1.config.JWTSecret
	assert.Equal(t, "auto-generated-secret-for-testing", firstSecret)

	// Verify it was saved to DB
	dbSecret, err := am1.loadJWTSecretFromDB()
	require.NoError(t, err)
	assert.Equal(t, firstSecret, dbSecret)

	// Second manager: auto-generated config value, but DB has persisted value â†’ use DB value
	cfg2 := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "different-auto-generated-secret",
		JWTSecretAutoGenerated: true,
	}
	manager2 := NewManager(cfg2, tmpDir)
	require.NotNil(t, manager2)

	am2 := manager2.(*authManager)
	// Should use the persisted DB value, not the new auto-generated one
	assert.Equal(t, firstSecret, am2.config.JWTSecret)
}

// TestJWTSecretPersistence_ExplicitOverridesDB verifies that an explicit config
// value takes priority over a persisted DB value
func TestJWTSecretPersistence_ExplicitOverridesDB(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "maxiofs-jwt-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	// First: create with auto-generated to populate DB
	cfg1 := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "initial-auto-secret",
		JWTSecretAutoGenerated: true,
	}
	manager1 := NewManager(cfg1, tmpDir)
	require.NotNil(t, manager1)
	am1 := manager1.(*authManager)
	assert.Equal(t, "initial-auto-secret", am1.config.JWTSecret)

	// Second: explicit config value should override DB
	cfg2 := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "my-explicit-secret-from-config",
		JWTSecretAutoGenerated: false,
	}
	manager2 := NewManager(cfg2, tmpDir)
	require.NotNil(t, manager2)

	am2 := manager2.(*authManager)
	assert.Equal(t, "my-explicit-secret-from-config", am2.config.JWTSecret)

	// DB should also be updated to the explicit value
	dbSecret, err := am2.loadJWTSecretFromDB()
	require.NoError(t, err)
	assert.Equal(t, "my-explicit-secret-from-config", dbSecret)
}

// TestJWTSecretPersistence_SetJWTSecret verifies runtime secret update
func TestJWTSecretPersistence_SetJWTSecret(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "maxiofs-jwt-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	cfg := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "original-secret",
		JWTSecretAutoGenerated: true,
	}
	manager := NewManager(cfg, tmpDir)
	require.NotNil(t, manager)

	am := manager.(*authManager)
	assert.Equal(t, "original-secret", am.config.JWTSecret)

	// Update secret at runtime (simulates cluster join)
	am.SetJWTSecret("new-cluster-secret")

	// In-memory value should be updated
	assert.Equal(t, "new-cluster-secret", am.config.JWTSecret)
	assert.False(t, am.config.JWTSecretAutoGenerated)

	// DB should be updated
	dbSecret, err := am.loadJWTSecretFromDB()
	require.NoError(t, err)
	assert.Equal(t, "new-cluster-secret", dbSecret)

	// New manager should pick up the persisted value
	cfg3 := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "yet-another-auto-secret",
		JWTSecretAutoGenerated: true,
	}
	manager3 := NewManager(cfg3, tmpDir)
	require.NotNil(t, manager3)
	am3 := manager3.(*authManager)
	assert.Equal(t, "new-cluster-secret", am3.config.JWTSecret)
}

// TestJWTSecretPersistence_EmptyDB verifies first-time behavior
func TestJWTSecretPersistence_EmptyDB(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "maxiofs-jwt-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	cfg := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "first-time-secret",
		JWTSecretAutoGenerated: true,
	}
	manager := NewManager(cfg, tmpDir)
	require.NotNil(t, manager)

	am := manager.(*authManager)
	// Secret should be used as-is
	assert.Equal(t, "first-time-secret", am.config.JWTSecret)

	// And persisted to DB
	dbSecret, err := am.loadJWTSecretFromDB()
	require.NoError(t, err)
	assert.Equal(t, "first-time-secret", dbSecret)
}

// TestJWTSecretPersistence_SystemSettingsTable verifies the jwt_secret row properties
func TestJWTSecretPersistence_SystemSettingsTable(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "maxiofs-jwt-test-*")
	require.NoError(t, err)
	defer os.RemoveAll(tmpDir)

	cfg := config.AuthConfig{
		EnableAuth:             true,
		JWTSecret:              "test-secret",
		JWTSecretAutoGenerated: true,
	}
	manager := NewManager(cfg, tmpDir)
	require.NotNil(t, manager)

	am := manager.(*authManager)
	db := am.store.db

	// Verify the row properties in system_settings
	var key, value, settingType, category string
	var editable int
	err = db.QueryRow(`
		SELECT key, value, type, category, editable
		FROM system_settings WHERE key = ?
	`, "jwt_secret").Scan(&key, &value, &settingType, &category, &editable)

	// system_settings table might not exist yet if settings manager hasn't been initialized
	// The auth manager creates the row directly, so the table must exist
	if err == sql.ErrNoRows {
		t.Skip("system_settings table doesn't have jwt_secret row - table may need initialization")
	}
	require.NoError(t, err)

	assert.Equal(t, "jwt_secret", key)
	assert.Equal(t, "test-secret", value)
	assert.Equal(t, "string", settingType)
	assert.Equal(t, "security", category)
	assert.Equal(t, 0, editable, "jwt_secret should not be editable via UI")
}
